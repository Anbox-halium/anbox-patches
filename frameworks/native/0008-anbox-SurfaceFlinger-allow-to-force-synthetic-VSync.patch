From 9489115c2da055264e76f2623eff6ad9e412d879 Mon Sep 17 00:00:00 2001
From: Asriel Dreemurr <asriel.danctnix@gmail.com>
Date: Tue, 30 Mar 2021 18:45:38 +0700
Subject: [PATCH] (anbox) SurfaceFlinger: allow to force synthetic VSync via
 property

If debug.sf.force_synthetic_vsync is set to 1, EventThread will
always issue fake VSync even if display is considered to be on.

Change-Id: I296f5bfe73715a7ad5842a3c42815292f8650c78
---
 services/surfaceflinger/Scheduler/EventThread.cpp | 8 +++++++-
 services/surfaceflinger/Scheduler/EventThread.h   | 2 ++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/services/surfaceflinger/Scheduler/EventThread.cpp b/services/surfaceflinger/Scheduler/EventThread.cpp
index 08f052c..d7afe01 100644
--- a/services/surfaceflinger/Scheduler/EventThread.cpp
+++ b/services/surfaceflinger/Scheduler/EventThread.cpp
@@ -30,6 +30,7 @@
 #include <bfqio/bfqio.h>
 
 #include <cutils/compiler.h>
+#include <cutils/properties.h>
 #include <cutils/sched_policy.h>
 
 #include <gui/DisplayEventReceiver.h>
@@ -175,6 +176,11 @@ EventThread::EventThread(VSyncSource* src, std::unique_ptr<VSyncSource> uniqueSr
     }
     mVSyncSource->setCallback(this);
 
+    mForceSyntheticVsync = property_get_bool("debug.sf.force_synthetic_vsync", false);
+    if (mForceSyntheticVsync) {
+        mVSyncState->synthetic = true;
+    }
+
     mThread = std::thread([this]() NO_THREAD_SAFETY_ANALYSIS {
         std::unique_lock<std::mutex> lock(mMutex);
         threadMain(lock);
@@ -283,7 +289,7 @@ void EventThread::onScreenReleased() {
 
 void EventThread::onScreenAcquired() {
     std::lock_guard<std::mutex> lock(mMutex);
-    if (!mVSyncState || !mVSyncState->synthetic) {
+    if (!mVSyncState || !mVSyncState->synthetic || mForceSyntheticVsync) {
         return;
     }
 
diff --git a/services/surfaceflinger/Scheduler/EventThread.h b/services/surfaceflinger/Scheduler/EventThread.h
index dd23b88..be202ac 100644
--- a/services/surfaceflinger/Scheduler/EventThread.h
+++ b/services/surfaceflinger/Scheduler/EventThread.h
@@ -205,6 +205,8 @@ private:
     // and support headless mode by injecting a fake display with synthetic VSYNC.
     std::optional<VSyncState> mVSyncState GUARDED_BY(mMutex);
 
+    bool mForceSyntheticVsync = false;
+
     // State machine for event loop.
     enum class State {
         Idle,
-- 
2.17.1

